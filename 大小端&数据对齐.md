## 大小端模式

- 大端模式（Big_endian）

字数据的高字节存储在低地址中，数据的低字节则存放在高地址中。

- 小端模式（Little_endian）

字数据的高字节存储在高地址中，数据的低字节则存放在低地址中。

![bigEndian](D:\GitHub\C-plus-plus-Knowledge\images\bigEndian.png)

![littleEndian](D:\GitHub\C-plus-plus-Knowledge\images\littleEndian.png)

```c
int checkSystem( )
{
   union check
   {
      int i;
      char ch;
   } c;
   c.i = 1;
   return (c.ch ==1);
} // 利用union类型数据的特点：所有成员的起始地址一致。ch取出的是低地址的值，则大端模式下，返回0；小端模式下，返回1。
```

## 数据对齐

许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个K值（通常是2、4或8）的倍数，这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计。

比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该int数据。数据对齐(Data Alignment) 这个要求可以提高存储器系统的性能，减少寻址次数，代价是浪费了一些空间。换句话说是用相对廉价的空间换得时间。

Linux沿用的对齐策略是，2字节数据类型（如short）的地址必须是2的倍数，而较大的数据类型（如int,int*,float,double）的地址必须是4的倍数。

Windows的对齐策略：任何K字节基本对象的地址都必须是K的倍数，K =2，4或8。特别地，它要求一个double或者long long类型数据的地址应该是8的倍数。

对于包含结构体的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构体元素都满足它的对齐要求。而结构体本身对它的起始地址也有一些对齐要求。

数据对齐有两种方式，一种是自然对齐，另一种是强制对齐。

### 自然对齐

结构体数据自然对齐要满足的条件：

1. **假设数据的偏移量X，数据所属类型所占字节数b，那么需要满足 X % b == 0。**

```c
struct s {
	int   i;
	char  c;
	int   j;
};
```

要满足i和j的4字节对齐要求，i的偏移为0，c的偏移为4，j的偏移为8，在c和j之间插入3字节的间隙，整个结构的大小为12字节。

此外，编译器必须保证任何struct s*类型的指针p都满足4字节对齐，让指针的值为Xp，则Xp必须是4的倍数（0也可以，可以整除4），这样就保证了p->i（地址Xp），p->j（地址Xp+8）都满足它们的4字节对齐要求。

```c
struct A
{
    int i;
    double d;
    char c;
    short s;
 };
```

i的偏移量是0，d的偏移量是8，c的偏移量是16，s的偏移量是18。加起来为20字节，不是8的整数倍，所以总字节数为24。

1.  **假设结构体中所占总字节数为N，结构体中占字节数最大的数据类型的字节数为B。那么需要满足 N % B == 0。** 编译器结构的末尾可能需要一些填充。

```c
struct s {
	int  i;
	int  j;
	char c;
};
```

如果将结构打包成9个字节，只要保证结构的起始地址满足4字节对齐要求，我们仍能满足字段i和j的对齐要求，但是考虑到下述声明：

```c
struct s d[4]
```

分配9 个字节，不可能满足d的每个元素的对齐要求，因为这些元素的地址分别为Xd, Xd+9, Xd+18, Xd+27，要求补齐到4的倍数，即12字节，浪费3个字节，即d的元素地址为Xd, Xd+12, Xd+24, Xd+36。

由于结构体所占空间与其内部元素的类型有关，而且与不同类型元素的排列有关，因此在定义结构体时，在元素类型及数量确定之后，我们还应该注意一下其内部元素的定义顺序。

1. 含有构造数据类型（数组、结构体和联合体）的情况。首先要明确的是计算存储空间时要把构造体看作一个整体来为其开辟存储空间；其次要明确的是在最后补齐时是按照所有元素中的基本数据类型元素的最长宽度来补齐的，也就是说虽然要把构造体看作整体，但在补齐的时候并不会按照所含结构体所占存储空间的长度来补齐的（即使它可能是最长的）。

```c
struct X
{
     char a;
     int b;
     double c;
};
   
struct Y
{
    char a;
    X b;
};
```

 经测试，可知sizeof(X)为16，sizeof(Y)为24。

即计算Y的存储长度时，在存放第二个元素b时的初始位置是在double型的长度8的整数倍处，而非16的整数倍处，即系统为b所分配的存储空间是第8~23个字节。

如果将Y的两个元素char型的a和X型的b调换定义顺序，则系统为b分配的存储位置是第0~15个字节，为a分配的是第16个字节，加起来一共17个字节，不是最长基本类型double所占宽度8的整数倍，因此要补齐到8的整数倍，即24。测试后可得sizeof(Y)的值为24。

### 强制对齐

需要用到  **#pragma pack** 

```c
#pragma pack(1)
struct B
{
	int i;
	double d;
	char c;
	short s;
};
#pragma pack()
```

#pragma pack() 有一个参数。

结构体的强制对齐要满足：

- 假设数据的偏移量X，数据所属类型所占字节数b1，#pragma pack(b2)的参数为b2，那么需满足  **X % ( min ( b1, b2) ) == 0** 。
- 假设结构体中所占总字节数为N，结构体中占字节数最大的数据类型（比如结构体A中的double）的字节数为B1，#pragma pack(b2)的参数为B2，那么应该满足 **N % ( min( B1, B2) ) == 0** 。

#pragma pack( n ) 的作用就在上述两个条件中体现了，也体现了强制对齐与自然对齐的区别。

```c
#pragma pack(1)
struct B
{
	int i； //偏移量为0，能够整除min (4, 1)
	double d；//偏移量为4，能够整除min (8, 1)
	char c；//偏移量为12，能够整除min (1, 1)
	short s；//偏移量为13，能够整除min (2, 1)
}
#pragma pack()
```

最后的总字节数为15。又15能够整除min (8, 1)，满足条件2，因此最后的总字节数为15。

自然对齐其实是有默认的pack，在我的计算机中它的默认值为8（可通过#pragma pack(show)来查询默认值，运行的时候在警告栏中显示），也就是本文中的自然对齐与

```c
#pragma pack(8)
struct A
{
    int i;
    double d;
    char c;
    short s;
};
#pragma pack()
```

是等价的。