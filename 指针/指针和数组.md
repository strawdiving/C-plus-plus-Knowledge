# 指针和数组
数组的数组名其实可以看作一个指针。通常将数组的首地址称为数组的指针，而将指向数组元素的指针变量称为指向数组的指针变量。

一个整数在内存中占两个连续的存储单元，排在前面的那个存储单元的地址就是这个整数的地址。数组元素的地址同上。数组中的若干个数组元素在内存中是依次连续存放的，占一片连续的内存单元，其中排在最前面的那个数组元素的地址就是这个数组的地址。 

**数组名是表示数组首地址的地址常量!** 
```c
int  *p   与  int  q[10]
```
系统只给p分配能保存一个指针值的内存区(一般4字节）；而给q分配4*10字节的内存区。

下面总结一下数组的数组名的问题。声明了一个数组TYPEarray[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE[n]；第二，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。

1. 数组指针

数组名是指针（地址）**常量**

形参数组实质上是指针变量，即int  q[ ] 等价于 int *q

数组的首地址称为数组指针。C++规定，数组的首地址可用数组名a表示，因此，数组a的数组指针=a=&a[0]。在C++中数组名a可用于表示数组的首地址，所以数组名a可作为数组指针使用。因此：p=a与p=&a[0] 的作用是相同的。数组名a，可以加减，但不能用来进行赋值运算、"++"、"--"等运算。
```c
a=a+1; //× 
p=p+1; //√ 
a++; //×  
p++; //√
```
2. 数组指针变量

存放数组元素地址的变量称为数组指针变量。当指针变量指向数组首地址后，就可使用该指针变量对数组中任何一个元素变量进行存取操作。
### 一维数组访问数组元素

1. 一维数组的任何一个元素的地址，都可以用其数组名加上一个偏移量来表示。 
```c
p+i=a+i=&a[i] //p+i、a+i 均表示第i个元素的地址&a[i]
```
2. 一维数组的第i个元素可用四种方式引用
```c
a[i]、*(p+i) 、*(a+i)、p[i]。*(p+i) =*(a+i)=p[i]= a[i]
```

### 二维数组访问数组元素
在C++中，二维数组元素值在内存中是按行的顺序存放的，与一维数组类似，可用指针变量来访问二维数组元素。

![2D_array](https://github.com/strawdiving/C-plus-plus-Knowledge/blob/master/images/2D_array.png)

第i行中的元素a[i][0]、a[i][1]、a[i][2]组成一维数组a[i] (i=0,1,2)
a —— 二维数组的首地址，即第0行的首地址

| Col1      |     Col2 | 
| :-------- | --------:|
| 第i行的首地址    |   `a+i 、&a[i]` |  
| 第i行第0列元素的地址    |   `a[i]、 *(a+i)、 &a[i][0]` |  
| 元素a[i][j]的地址    |   `a[i]+j 、*(a+i)+j 、&a[i][0]+j、&a[i][j]` |  
| 第i行第j列元素a[i][j]值    |  `*(a[i]+j)、*(*(a+i)+j) 、 *(&a[i][0]+j)、a[i][j]` |  
注：   a+i=a[i]=&a[i][0]=*（a+i） 行地址的值与行首地址的值相等，但含义不同。
- a+i表示第i行首地址，指向行
- a[i]=&a[i][0]=*（a+i），表示第i行第0列元素地址，指向列

二维数组名a可用于表示二维数组的首地址，但C++规定该首地址并不是二维数组中第0行第0列的地址(即a≠&a[0][0])，而是第0 行的行地址，即a=a+0=&a[0]。

**行地址**

 a+i与&a[i]只能用于指向一维数组的指针变量，而不能用于普通指针变量，如果要将行地址赋数组指针变量，必须用强制类型转换，如：
```c
int *p=(int *) (a+0);
p=*a;       // √
p=&a[0][0]; // √
p=(int *)a; // √
p=a;        // X
```

因为数组名可用来表示数组的首地址，所以一维数组名a[i]可表示一维数组 (a[i][0],a[i][1],a[i][2])的首地址&a[i][0]，即可表示第i行元素的首地址。一维数组的第i个元素地址可表示为：数组名+i。二维数组a中第i行第j列元素a[i][j]的地址可用a[i]+j来表示，而元素a[i]][j]的值为：*(a[i]+j)。

在不同的表达式中数组名array可以扮演不同的角色。在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。在表达式`*array`中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。`sizeof(*array)`测出的是数组单元的大小。表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是`TYPE*`，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。
```c
int(*ptr)[10];
则在32位程序中，有： 
sizeof(int(*)[10])==4 
sizeof(int[10])==40 
sizeof(ptr)==4 
```

实际上，sizeof(对象)测出的都是对象自身的类型的大小。 
当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。左值必须是一个变量，或是一个解引用的指针。
## 二维数组与指向一维数组的指针变量的关系
```c
int  a[5][10]，(*p)[10];   p = a ;
```

 - p的值是某个包含10个元素的一维数组的首地址，p是行指针，可让p指向二维数组某一行
 - p指向的一维数组的元素个数和二维数组列数必须相同
 - 系统给数组a分配4 * 5 * 10个字节的内存区，系统只给变量p分配能保存一个指针值的内存区(4字节)
 - 数组名a的值是一个指向有10个元素的一维数组的指针常量
 - `p[0]=&a[0][0]; p[1]=&a[1][0]`;
 - p=a+i  使 p指向二维数组的第i行
 - `*( * (p+i)+j) 等价于 a[i][j]`
 - 	二维数组形参实际上是一个指向一维数组的指针变量
 即  `fun(int  x[ ][10])  等价于 fun(int (*x)[10])`
在函数fun中两者都可以有x++;x=x+2;等操作！
但在变量定义(不是形参）时，两者不等价;

![2D_array1](https://github.com/strawdiving/C-plus-plus-Knowledge/blob/master/images/2D_array1.png)
```c
p=a[0];             // X
p=*a;               // X
p=&a[0][0];         // X
p=a; 等价于 p=&a[0]; // √
```

## 指针数组与二级指针的关系
```c
int  **p   与  int  *q[10]
```   

- 系统只给p分配能保存一个指针值的内存区；而给q分配10个内存区，每个内存区均可保存一个指针值
- 指针数组名是二级指针常量
- p=q;   p+i 是q[i]的地址
- 指针数组作形参，int *q[ ]与int **q完全等价；但作为变量定义两者不同