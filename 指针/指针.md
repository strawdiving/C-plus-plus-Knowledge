# 指针
指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。指针是一个指示器，它告诉程序在内存的哪块区域可以找到数据。

需要搞清指针的四方面的内容：
- 指针的类型
- 指针所指向的类型
- 指针的值或者叫指针所指向的内存区
- 指针本身所占据的内存区
## 指针的类型
从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。
```c
 int* ptr;//指针的类型是int*   
 char* ptr;//指针的类型是char*
 int** ptr;//指针的类型是int** 
 int(*ptr)[3];//指针的类型是int(*)[3] 
 int*(*ptr)[4];//指针的类型是int*(*)[4] 
``` 
### 多重指针
一个指针变量的内容就是内存中某个存储区域的地址，这个存储区域中存放的值可以是一个基本数据类型的数据，也可以是另一个存储区域的地址。我们把这种类型的指针叫做多重指针。

二重指针(指向指针的指针)的一般说明形式为：
```c
类型说明符    **指针变量名;
```
## 指针所指向的类型
当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符 * 去掉，剩下的就是指针所指向的类型。
```c
int*ptr;//指针所指向的类型是int 
int**ptr;//指针所指向的的类型是int*
int(*ptr)[3];//指针所指向的的类型是int()[3] 
int*(*ptr)[4];//指针所指向的的类型是int*()[4]
``` 
指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。

指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 **sizeof(指针所指向的类型)** 的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
### 指针变量的初始化
一般形式：[存储类型] 数据类型  * 指针名=初始地址值；
                              
指针变量是把其它变量的地址作为内容的变量。指针变量定义后，变量值不确定， **指针变量必须先赋值,再使用** ！

指针所指向的类型已经有了，但由于指针还未初始化，而声明一个指针不会“创建”用于存储的内存空间，所以它所指向的内存区是不存在的，或者说是无意义的.

指针变量定义后其值为随机数，若此随机数为系统区的地址，则对该指针变量所指系统区某存储单元进行赋值运算，将改变系统区该单元中内容，可能导致系统的崩溃。所以，指针变量定义后必须赋某个变量的地址或NULL。
```c
int   i=10;
int   *p; 
*p=i; 
```
   
![pointer_value](https://github.com/strawdiving/C-plus-plus-Knowledge/blob/master/images/pointer_value.png)

 给指针变量赋初值有三种情况：
 - 第一种情况是用取地址运算符"&"将变量地址赋给指针变量。如：p=&a；
 - 第二种情况是将一个指针变量中的地址赋给另一个指针变量，如：p1=p；
 - 第三种情况是给指针变量赋空值0，如q=0；表示该指针变量不指向任何变量。
### NULL指针
作为一个特殊的指针变量，表示不指向任何东西（与未对p赋值不同）。可以通过赋0值变为NULL指针。
```c
int *p = 0;
```
对一个NULL指针进行解引用操作是非法的。在对指针进行解引用操作前，要确保它非NULL指针。
### 空（类型）指针
```c
一般形式： void  *类型指针;
```
 表示不指定p是指向哪一种类型数据的指针变量。使用时要进行强制类型转换。
```c
char  *p1;
void  *p2;
p1=(char*)p2;
```
分配内存空间的函数返回一个空类型的指针。
```c
void  *malloc(int  n); //例如：int *p= (int *) malloc(2);
```
## 指针本身所占据的内存区
指针本身占了多大的内存？因为指针变量用于存放变量地址，在32位平台里地址通常为4字节，所以指针变量的长度均为4个字节。你只要用函数sizeof(指针的类型)测一下就知道了。
### 指针变量的运算
- 直接访问：按变量地址存取变量值，如 i = 3
- 间接访问/解引用访问：通过一个指针访问它所指向的地址的过程，如* i_pointer=20
####  运算符&和*
&是取地址运算符，返回其操作数的地址。地址运算符的操作数必须是一个变量(或数组元素)。

* 又称为"间接引用运算符"，它表示从相应的存储单元中获取某种类型的数据值,只能作用于指针类型的表达式。

&a的运算结果是一个指针，指针的类型是a的类型加个 * ，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。* p的运算结果就五花八门了。总之 * p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。 
#### 指针变量的运算
指针变量的运算有三种：赋值运算、关系运算与算术运算。
1. 指针变量赋值运算
指针变量赋值运算就是将变量的地址赋给指针变量。
2. 指针变量的算术运算
- 指针±整数（变量的自加、自减、加n和减n操作）<指针变量>=<指针变量> +/- n * sizeof(<指针变量类型>)，即指针所指向的地址由原来的地址向高/低地址方向前进了n * sizeof(<指针变量类型>)个字节。
- 指针1－指针2 —> 整数（多少个数）
3. 指针变量的关系运算
指针变量的关系运算是指针变量值的大小比较，即对两个指针变量内的地址进行比较，如：指针1<指针2。
4. 指针运算符的混合运算与优先级
- 指针运算符* 与取地址运算符&的优先级相同，按自右向左的方向结合
```c
int a, *p=&a;
```
   则表达式：&* p 的求值顺序为先" * "后" & "，即& (* p)=&a=p 。
   而表达式：* &a 的求值顺序为先"&"后" * "，即* (&a)=*p=a 。
   - "++"、"――"、"*"、"&"的优先级相同，按自右向左方向结合
   
```c
int a[4]={100,200,300,400},b;
int * p=&a[0];
b=*p++= *（p++）, // *p即100先赋给b，p= &a[1]
b=*++p = *(++p) = *(a[2])= 300, p = &a[2]
b=(*p)++ , //先取出*p（即a[2]）的值并赋给b，然后将*p的值即a[2]内容加1 
p = &a[2],a[2] = 300+1 = 301
b=*(p++),同*p++,b=a[2]=301,p = &a[3]
b=++*p,先“*”再“++”，b=++(*p)=++a[2] = 401，p =  &a[3]
```
说明：在定义数组时，数据a的地址是由操作系统存储管理动态分配的，因此，数组a的地址是不确定的，每次运行的结果都可能会不同。一般用十六进制数表示。
## 特殊的指针——引用
引用有时候应用起来要比指针要灵活，用它做返回的时候是不产生任何变量的副本的这样减小了内存的占用，提高执行的速度。引用使用起来要比指针好理解，比较直观。当引用作为参数时，不会改变参数的地址，因此可以作为左值。**左值必须是一个变量，或是一个解引用的指针**。

