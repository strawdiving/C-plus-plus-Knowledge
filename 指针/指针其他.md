# 指针其他
## 指针类型转换
当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。
```c
float f=12.3; 
float *fptr=&f; 
int*p;
```
在上面的例子中，假如我们想让指针p指向实数f，表达式&f的结果是一个指针，指针的类型是float*,它指向的类型是float。两者不一致，直接赋值的方法是不行的。为了实现我们的目的，需要进行"强制类型转换"：
```c
p=(int*)&f;
```
如果有一个指针p，我们需要把它的类型和所指向的类型改为TYPE*和TYPE， 那么语法格式是：
```c
(TYPE*)p;
```
 这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE*，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。而原来的指针p的一切属性都没有被修改。 
 
一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，也会发生指针类型的转换。 
```c
void fun(char*); 
int a=125,b; 
fun((char*)&a); 
... 
... 
void fun(char*s) 
{ 
    char c; 
    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c; 
    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c; 
}
```
注意这是一个32位程序，故int类型占了四个字节，char类型占一个字节。函数fun的作用是把一个整数的四个字节的顺序来个颠倒。在实参和形参的结合过程中，我们必须进行一次从int * 类型到char * 类型的转换。编译器进行转换的过程：编译器先构造一个临时指针char* temp，然后执行temp=(char*)&a，最后再把temp的值传递给s。所以最后的结果是：s的类型是char*,它指向的类型是char，它指向的地址就是a的首地址。

## 指针的安全问题
内存问题：使用指针注意内存的分配和边界。使用指针过程中应该给变量一个适当的空间，以免产生不可见的错误。

在指针的强制类型转换：ptr1=(TYPE*)ptr2中，如果sizeof(ptr2的类型)大于sizeof(ptr1的类型)，那么在使用指针ptr1来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2的类型)小于sizeof(ptr1的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是不安全的。

### 动态分配　　
　　动态分配是指针的关键技术。它是用来在不必定义变量的情况下分配内存和让指针去指向它们。尽管这么说可能会让你迷惑，其实它真的很简单。下面的代码就是一个为一个整型数据分配内存的例子：
```c　
int *pNumber;
pNumber = new int;
```
第一行声明一个指针pNumber。第二行为一个整型数据分配一个内存空间，并让pNumber指向这个新内存空间。

　　
动态分配就是在函数返回或执行完毕时，你分配的这块内存区域是不会被删除的所以我们现在可以用动态分配重写上面的程序：当SomeFunction调用时，它分配了一个内存，并让pPointer指向它。这一次，当函数返回时，新的内存区域被保留下来，所以pPointer始终指着有用的信息，这是因为了动态分配。
```c
#include <iostream.h>　　
int *pPointer;　　
void SomeFunction()
{　　// 让指针指向一个新的整型
    pPointer = new int;
    *pPointer = 25;
}　　
void main()
{
    SomeFunction(); //为pPointer赋值
    cout<<"Value of *pPointer: "<<*pPointer<<endl;
    delete pPointer;
}　
```
分配了内存，别忘了回收。你动态地分配了一个内存空间，可它绝不会被自动删除。也就是说，这块内存空间会一直存在，直到你告诉电脑你已经使用完了。可结果是，你并没有告诉电脑你已不再需要这块内存空间了，所以它会继续占据着内存空间造成浪费，甚至你的程序运行完毕，其它程序运行时它还存在。如果你不删除它，你就会制造一起“内存漏洞”，而让内存逐渐地泄漏。当这样的问题积累到一定程度，最终将导致系统崩溃。所以这是很重要的，在你用完它以后，请释放它的空间。

指针错误的原因有以下几点：
1. 指针未初始化

指针的初始化，不是指指针的定义，而是指针变量存储的数值是个无效的数值。比如定义`float a;`这个a会分配一个地址，但初始值是一个乱七八糟的数据。同样，`float *a;`也会为a分配一个地址，初始值也是乱七八糟的数据。初始化可以将`a = NULL`，这样在以后的程序中可以增加`if(a == NULL)`来判断指针是否有效，否则不行。或者为指针分配或者指定空间。如 `float *a = new float;`或者`float b; float *a = &b;`都可以为指针指向一块内存以实现初始化。

2. 指针越界

指针越界是个比较难以捕捉的错误。如果测试不全面，不容易被发现。对于为指针分配的空间大小，程序员一定要时刻注意。

3. 指向局部变量的指针

指针是记录某块内存起始地址的变量，要使指针有效，则必须确保这块内存有效。用new分配的内存空间，只要不delete，则一直有效。但是对于指向某个变量地址的指针，程序员必须清楚该变量的作用域。如果离开了变量的作用域，该变量的内存空间就会被系统自动回收，再使用指针时，将会发生错误。这是程序中最容易出现的错误。

4. 指针指向的转移

有些初涉C 的程序员，常常会写出这样的程序：
```c
char *pChar = new char;
char chs;
pChar = &chs;
delete pChar;
```	
他们的目的是想将chs内容传递给pChar指针指向的内存。但这样写，将会使pChar先前指向的空间变成垃圾地址，因为地址无法再获取了。俗称野指针。将会导致内存泄漏。而且，在调用delete pChar时，也会发生异常错误。因为不是new的空间是不能使用delete删除的。因为pChar已经转到指向chs这个变量的地址了。
### 其他
变量：是对程序中数据存储空间的抽象

变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++ 程序员常常把变量称为“变量”或“对象（object）”。

左值（发音为 ell-value）：左值可以出现在赋值语句的左边或右边。  
右值（发音为 are-value）：右值只能出现在赋值的右边，不能出现在赋值语句的左边。
